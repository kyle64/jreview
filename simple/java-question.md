## 1.	什么是线程？
    线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。 

## 2.	什么是线程安全和线程不安全？
    线程安全
    线程安全: 就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。
    
    一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。 Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。
    
    线程不安全
    线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据
    
    如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
    
    线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

## 3.	什么是自旋锁？
    基本概念
    自旋锁是SMP架构中的一种low-level的同步机制。
    
    当线程A想要获取一把自选锁而该锁又被其它线程锁持有时，线程A会在一个循环中自选以检测锁是不是已经可用了。
    
    自选锁需要注意：
    
    由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直在那里自旋，这就会浪费CPU时间。
    
    持有自旋锁的线程在sleep之前应该释放自旋锁以便其它线程可以获得自旋锁。
    
## 4.	什么是Java内存模型？
    Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量“ 和 ”从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来正确实现以上事情。
    
    Java包含了几个语言级别的关键字，包括：volatile, final以及synchronized，目的是为了帮助程序员向编译器描述一个程序的并发需求。Java内存模型定义了volatile和synchronized的行为，更重要的是保证了同步的java程序在所有的处理器架构下面都能正确的运行。
    
    “一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致的。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后面会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到该操作的结果，这反映了缓存的影响。
    
    此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其能在最佳顺序的情况下来执行操作。在内存模型的限定之内，我们能够获取到更高的性能。
    
    concurrent.ClassReordering.java
    让我们看在两个并发线程中执行这段代码，读取Y变量将会得到2这个值。因为这个写入比写到X变量更晚一些，程序员可能认为读取X变量将肯定会得到1。但是，写入操作可能被重排序过。如果重排序发生了，那么，就能发生对Y变量的写入操作，读取两个变量的操作紧随其后，而且写入到X这个操作能发生。程序的结果可能是r1变量的值是2，但是r2变量的值为0。

## 4.1  JVM内存结构
    JVM内存结构主要有三大块：堆内存、方法区和栈。
    
    堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配；方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。
    
    JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)
    
## 4.2  java堆（Java Heap）
    可通过参数 -Xms 和-Xmx设置    
    Java堆是被所有线程共享,是Java虚拟机所管理的内存中最大的一块 Java堆在虚拟机启动时创建。
     
    Java堆唯一的目的是存放对象实例，几乎所有的对象实例和数组都在这里。
     
    Java堆为了便于更好的回收和分配内存，可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor区。
     
    新生代：包括Eden区、From Survivor区、To Survivor区，系统默认大小Eden:Survivor=8:1。
     
    老年代：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
     
    Survivor空间等Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可（就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的）。
     
    据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

## 4.3 java虚拟机栈(stack)
    可通过参数 栈帧是方法运行期的基础数据结构栈容量可由-Xss设置
    
    1.Java虚拟机栈是线程私有的，它的生命周期与线程相同。
    
    每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
    
    虚拟机栈是执行Java方法的内存模型(也就是字节码)服务：每个方法在执行的同时都会创建一个栈帧，用于存储 局部变量表、操作数栈、动态链接、方法出口等信息。
    
    局部变量表：32位变量槽，存放了编译期可知的各种基本数据类型、对象引用、returnAddress类型。
    
    操作数栈：基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。
    
    动态连接：每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接应用，这部分称为动态连接
    
    方法出口：返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。
    
    局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的。
    
    在方法运行期间不会改变局部变量表的大小。主要存放了编译期可知的各种基本数据类型、对象引用 （reference类型）、returnAddress类型）。
    
    java虚拟机栈,规定了两种异常状况：
    
    如果线程请求的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
    
    如果虚拟机栈动态扩展，而扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
    
## 4.4 本地方法栈
    可通过参数 栈容量可由-Xss设置
    
    虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。
    
    本地方法栈则是为虚拟机使用到的Native方法服务。有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一
    
## 4.5 方法区（Method Area）
    可通过参数-XX:MaxPermSize设置
    
    线程共享内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，方法区也称持久代（Permanent Generation）。
    
    虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。
    
    如何实现方法区，属于虚拟机的实现细节，不受虚拟机规范约束。
    
    方法区主要存放java类定义信息，与垃圾回收关系不大，方法区可以选择不实现垃圾回收,但不是没有垃圾回收。
    
    方法区域的内存回收目标主要是针对常量池的回收和对类型的卸载。
    
    运行时常量池，也是方法区的一部分，虚拟机加载Class后把常量池中的数据放入运行时常量池。
    
## 4.6 运行时常量池
    JDK1.6之前字符串常量池位于方法区之中。 JDK1.7字符串常量池已经被挪到堆之中。
    
    可通过参数-XX:PermSize和-XX:MaxPermSize设置
    
    常量池（Constant Pool）：常量池数据编译期被确定，是Class文件中的一部分。存储了类、方法、接口等中的常量，当然也包括字符串常量。
    
    字符串池/字符串常量池（String Pool/String Constant Pool）：是常量池中的一部分，存储编译期类中产生的字符串类型数据。
    
    运行时常量池（Runtime Constant Pool）：方法区的一部分，所有线程共享。虚拟机加载Class后把常量池中的数据放入到运行时常量池。常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目资源关联最多的数据类型。
    
    常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。
    
    字面量：文本字符串、声明为final的常量值等。
    
    符号引用：类和接口的完全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。
    
## 4.7 直接内存
    可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。

    直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。

## 4.8 总结的简单一点
    java堆（Java Heap）
                       
    可通过参数 -Xms 和-Xmx设置
    1. Java堆是被所有线程共享,是Java虚拟机所管理的内存中最大的一块 Java堆在虚拟机启动时创建
    2. Java堆唯一的目的是存放对象实例，几乎所有的对象实例和数组都在这里
    3. Java堆为了便于更好的回收和分配内存，可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor区
        
    新生代：包括Eden区、From Survivor区、To Survivor区，系统默认大小Eden:Survivor=8:1。
    老年代：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
    
    java虚拟机栈(stack)
      
    可通过参数 栈帧是方法运行期的基础数据结构栈容量可由-Xss设置
    1. Java虚拟机栈是线程私有的，它的生命周期与线程相同。
    2. 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
    3. 虚拟机栈是执行Java方法的内存模型(也就是字节码)服务：每个方法在执行的同时都会创建一个栈帧，用于存储 局部变量表、操作数栈、动态链接、方法出口等信息
    

## 5.	什么是CAS？
    CAS（compare and swap）的缩写，中文翻译成比较并交换。
    
    CAS 不通过JVM,直接利用java本地方 JNI（Java Native Interface为JAVA本地调用）,直接调用CPU 的cmpxchg（是汇编指令）指令。
    
    利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法,实现原子操作。其它原子操作都是利用类似的特性完成的。
    
    整个java.util.concurrent都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。
    
    CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。
    
    CAS应用
    CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
    
    CAS优点
    确保对内存的读-改-写操作都是原子操作执行
    
    CAS缺点
    CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作
    
    总结
    使用CAS在线程冲突严重时，会大幅降低程序性能；CAS只适合于线程冲突较少的情况使用。
    
    synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。
    
## 6.	什么是乐观锁和悲观锁？
    悲观锁
    Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。
    
    乐观锁
    乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。
    
## 7.	什么是AQS？
    AbstractQueuedSynchronizer简称AQS，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时设计的大量细节问题。
    
    AQS使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态waitStatus。
    
## 8.	什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？
    原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。
    
    int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。
    
    为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。
    
    到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。
    
## 9.	什么是Executors框架？
    Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。
    
    Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。
    
    无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。
    
    利用Executors框架可以非常方便的创建一个线程池，
    
    Java通过Executors提供四种线程池，分别为：
    
    newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    
    newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
    
    newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
    
    newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 
    
## 10.	什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？
    阻塞队列是一个在队列基础上又支持了两个附加操作的队列。
    
    2个附加操作：
    
    支持阻塞的插入方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。 支持阻塞的移除方法：队列空时，获取元素的线程会等待队列变为非空。

    JDK 7 提供了7个阻塞队列，如下
    
    1、ArrayBlockingQueue 数组结构组成的有界阻塞队列。
    
    此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。
    
    2、LinkedBlockingQueue一个由链表结构组成的有界阻塞队列
    
    此队列按照先出先进的原则对元素进行排序
    
    3、PriorityBlockingQueue支持优先级的无界阻塞队列
    
    4、DelayQueue支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素
    
    5、SynchronousQueue不存储元素的阻塞队列，每一个put必须等待一个take操作，否则不能继续添加元素。并且他支持公平访问队列。
    
    6、LinkedTransferQueue由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了tryTransfer和transfer方法
    
    transfer方法
    
    如果当前有消费者正在等待接收元素（take或者待时间限制的poll方法），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。
    
    tryTransfer方法
    
    用来试探生产者传入的元素能否直接传给消费者。，如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。
    
    7、LinkedBlockingDeque链表结构的双向阻塞队列，优势在于多线程入队时，减少一半的竞争。
| 方法\处理方式 | 抛出异常 | 返回特殊值 | 一直阻塞 | 超时退出 |
| --- | --- | --- | --- | --- |
| 插入方法 | add(e) | offer(e) | put(e) | offer(e,time,unit) |
| 移除方法 | remove() | poll() | take() | poll(time,unit) |
| 检查方法 | element() | peek() | 不可用 | 不可用 |

## 11.	什么是Callable和Future?
    Callable 和 Future 是比较有趣的一对组合。当我们需要获取线程的执行结果时，就需要用到它们。Callable用于产生结果，Future用于获取结果。
    
    Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，必须等待它返回的结果。java.util.concurrent.Future对象解决了这个问题。
    
    在线程池提交Callable任务后返回了一个Future对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法，等待Callable结束并获取它的执行结果。
    
    代码示例
    
    Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。
    
    为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。
    
## 12.	什么是FutureTask?
    FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果，因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。另外，FutureTask还可以确保即使调用了多次run方法，它都只会执行一次Runnable或者Callable任务，或者通过cancel取消FutureTask的执行等。
    
    1. 执行多任务计算
    FutureTask执行多任务计算的使用场景
    利用FutureTask和ExecutorService，可以用多线程的方式提交计算任务，主线程继续执行其他任务，当主线程需要子线程的计算结果时，在异步获取子线程的执行结果。
    
    2. 高并发环境下
    FutureTask在高并发环境下确保任务只执行一次
    在很多高并发的环境下，往往我们只需要某些任务只执行一次。这种使用情景FutureTask的特性恰能胜任。
    
## 13.	什么是同步容器和并发容器的实现？
    一、同步容器
    主要代表有Vector和Hashtable，以及Collections.synchronizedXxx等。 锁的粒度为当前对象整体。 迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛出ConcurrentModificationException。
    
    二、并发容器
    主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。 锁的粒度是分散的、细粒度的，即读和写是使用不同的锁。 迭代器具有弱一致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。
    
    JDK 7 ConcurrentHashMap
    
    采用分离锁技术，同步容器中，是一个容器一个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若干段，每段维护一个锁，以达到高效的并发访问；
    
    JDK 8 ConcurrentHashMap
    
    采用分离锁技术，同步容器中，是一个容器一个锁，但在ConcurrentHashMap中，会将hash表的数组部分分成若干段，每段维护一个锁，以达到高效的并发访问；
    
    三、阻塞队列
    主要代表有LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue(Comparable,Comparator)、SynchronousQueue。 提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。 适用于生产者、消费者模式（线程池和工作队列-Executor），同时也是同步容器
    
    四、双端队列
    主要代表有ArrayDeque和LinkedBlockingDeque。 意义：正如阻塞队列适用于生产者消费者模式，双端队列同样适用与另一种模式，即工作密取。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。 如果一个消费者完成了自己双端队列中的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。 在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。 适用于：网页爬虫等任务中
    
    五、比较及适用场景
    如果不需要阻塞队列，优先选择ConcurrentLinkedQueue； 如果需要阻塞队列，队列大小固定优先选择ArrayBlockingQueue，队列大小不固定优先选择LinkedBlockingQueue； 如果需要对队列进行排序，选择PriorityBlockingQueue； 如果需要一个快速交换的队列，选择SynchronousQueue； 如果需要对队列中的元素进行延时操作，则选择DelayQueue。
    
## 14.	什么是多线程？优缺点？
    什么是多线程？优缺点？
    什么是多线程？
    
    多线程：是指从软件或者硬件上实现多个线程的并发技术。
    
    多线程的好处：
    
    使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载
    
    发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好
    
    多线程的缺点：
    
    大量的线程降低代码的可读性；
    
    更多的线程需要更多的内存空间
    
    当多个线程对同一个资源出现争夺时候要注意线程安全的问题。
    
## 15.	什么是多线程的上下文切换？
    即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms）
    
    上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行
    
    CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态
    
    从任务保存到再加载的过程就是一次上下文切换
    
## 16.	ThreadLocal的设计理念与作用？
    Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量
    InheritableThreadLocal类是ThreadLocal类的子类。ThreadLocal中每个线程拥有它自己的值，与ThreadLocal不同的是，InheritableThreadLocal允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。
## 17.	ThreadPool（线程池）用法与优势？
    为什么要用线程池:
    减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
    
    可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。
    
    Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。
    
    new Thread 缺点
    每次new Thread新建对象性能差。
    
    线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。
    
    缺乏更多功能，如定时执行、定期执行、线程中断。
    
    ThreadPool 优点
    减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务
    
    可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)
    
    减少在创建和销毁线程上所花的时间以及系统资源的开销
    
    如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存
    
## 18.	Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。
    参数：
    corePoolSize核心线程数大小，当线程数<corepoolsize ，会创建线程执行runnable<="" li="" style="box-sizing: border-box;">
    
    maximumPoolSize 最大线程数， 当线程数 >= corePoolSize的时候，会把runnable放入workQueue中
    
    keepAliveTime 保持存活时间，当线程数大于corePoolSize的空闲线程能保持的最大时间。
    
    unit 时间单位
    
    workQueue 保存任务的阻塞队列
    
    threadFactory 创建线程的工厂
    
    handler 拒绝策略
    
    任务执行顺序：
    当线程数小于corePoolSize时，创建线程执行任务。
    
    当线程数大于等于corePoolSize并且workQueue没有满时，放入workQueue中
    
    线程数大于等于corePoolSize并且当workQueue满时，新任务新建线程运行，线程总数要小于maximumPoolSize
    
    当线程总数等于maximumPoolSize并且workQueue满了的时候执行handler的rejectedExecution。也就是拒绝策略。
    
    ThreadPoolExecutor默认有四个拒绝策略：
    ThreadPoolExecutor.AbortPolicy() 直接抛出异常RejectedExecutionException
    
    ThreadPoolExecutor.CallerRunsPolicy() 直接调用run方法并且阻塞执行
    
    ThreadPoolExecutor.DiscardPolicy() 直接丢弃后来的任务
    
    ThreadPoolExecutor.DiscardOldestPolicy() 丢弃在队列中队首的任务
    
## 19.	synchronized和ReentrantLock的区别？
    基础知识
    可重入锁。可重入锁是指同一个线程可以多次获取同一把锁。ReentrantLock和synchronized都是可重入锁。
    
    可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。
    
    公平锁与非公平锁。公平锁是指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。
    
    CAS操作(CompareAndSwap)。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”
    
    Synchronized
    synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。然而synchronized也有一定的局限性
    
    例如：
    
    当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。
    
    如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。
    
    ReentrantLock
    ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。  
    
    *concurrent.lock()*, 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁
    
    tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；
    
    tryLock(long timeout,TimeUnit unit)**，如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；
    
    lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断
    
    ReentrantLock 一些特性
    
    等待可中断避免，出现死锁的情况（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false）
    
    公平锁与非公平锁多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。
    
    公平锁：线程获取锁的顺序和调用lock的顺序一样，FIFO；
    
    非公平锁：线程获取锁的顺序和调用lock的顺序无关，全凭运气。
    
    ReenTrantLock实现的原理：
    简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。
    
    总结一下
    在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。
    
    synchronized：
    
    在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好。
    
    ReentrantLock:
    
    ReentrantLock用起来会复杂一些。在基本的加锁和解锁上，两者是一样的，所以无特殊情况下，推荐使用synchronized。ReentrantLock的优势在于它更灵活、更强大，增加了轮训、超时、中断等高级功能。
    
    ReentrantLock默认使用非公平锁是基于性能考虑，公平锁为了保证线程规规矩矩地排队，需要增加阻塞和唤醒的时间开销。如果直接插队获取非公平锁，跳过了对队列的处理，速度会更快。
      
## 20.	Semaphore有什么作用？
    Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。
    
    Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，
    
    如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。
    
    由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了
    
## 21.	Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？
    Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。
    
    它的优势有：
    
    可以使锁更公平
    
    可以使线程在等待锁的时候响应中断
    
    可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间
    
    可以在不同的范围，以不同的顺序获取和释放锁
    
## 22.	Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？
    同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。
    
    而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性
    
## 23.	ConcurrentHashMap的并发度是什么？
    ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势

## 24.	ReentrantReadWriteLock读写锁的使用？
    Lock比传统线程模型中的synchronized方式更加面向对象，与生活中的锁类似，锁本身也应该是一个对象。两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个Lock对象。
    
    读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；
    
    如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！
    
    ReentrantReadWriteLock会使用两把锁来解决问题，一个读锁，一个写锁
    
    线程进入读锁的前提条件：
    
    没有其他线程的写锁
    
    没有写请求或者有写请求，但调用线程和持有锁的线程是同一个
    
    线程进入写锁的前提条件：
    
    没有其他线程的读锁
    
    没有其他线程的写锁
    
    读锁的重入是允许多个申请读操作的线程的，而写锁同时只允许单个线程占有，该线程的写操作可以重入。
    
    如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。
    
    对于同时占有读锁和写锁的线程，如果完全释放了写锁，那么它就完全转换成了读锁，以后的写操作无法重入，在写锁未完全释放时写操作是可以重入的。
    
    公平模式下无论读锁还是写锁的申请都必须按照AQS锁等待队列先进先出的顺序。非公平模式下读操作插队的条件是锁等待队列head节点后的下一个节点是SHARED型节点，写锁则无条件插队。
    
    读锁不允许newConditon获取Condition接口，而写锁的newCondition接口实现方法同ReentrantLock。
    
## 25.	CyclicBarrier和CountDownLatch的用法及区别？
    CyclicBarrier和CountDownLatch 都位于java.util.concurrent 这个包下
    
| CountDownLatch |	CyclicBarrier |
| --- | --- |
| 减计数方式 |	加计数方式 |
| 计算为0时释放所有等待的线程 |	计数达到指定值时释放所有等待线程 |
| 计数为0时，无法重置 |	计数达到指定值时，计数置为0重新开始 |
| 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 |	调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 |
| 不可重复利用 |	可重复利用 |  

    CountDownLatch， 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。
    CyclicBarrier会在所有线程任务结束之后，才会进行后续任务，具体可以看下面例子。
    
## 26.	LockSupport工具？
    1、LockSupport基本介绍与基本使用
    
    LockSupport是JDK中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞。java锁和同步器框架的核心 AQS: AbstractQueuedSynchronizer，就是通过调用 LockSupport .park()和 LockSupport .unpark()实现线程的阻塞和唤醒 的。
    
    LockSupport 很类似于二元信号量(只有1个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继 续 执行；如果许可已经被占用，当前线 程阻塞，等待获取许可。
    
    全部操作：
    park()/park(Object)
    
    等待通行准许。
    
    parkNanos(long)/parkNanos(Object, long)
    
    在指定运行时间（即相对时间）内，等待通行准许。
    
    parkUntil(long)/parkUntil(Object, long)
    
    在指定到期时间（即绝对时间）内，等待通行准许。
    
    unpark(Thread)
    
    发放通行准许或提前发放。（注：不管提前发放多少次，只用于一次性使用。）
    
    getBlocker(Thread)
    
    进入等待通行准许时，所提供的对象。
    
    主要用途：
    当前线程需要唤醒另一个线程，但是只确定它会进入阻塞，但不确定它是否已经进入阻塞，因此不管是否已经进入阻塞，还是准备进入阻塞，都将发放一个通行准许。
    
    正确用法：
    把LockSupport视为一个sleep()来用，只是sleep()是定时唤醒，LockSupport既可以定时唤醒，也可以由其它线程唤醒。
    
    LockSupport是不可重入 的，如果一个线程连续2次调用 LockSupport .park()，那么该线程一定会一直阻塞下去。
    
## 27.	Condition接口及其实现原理？
    Condition自己也维护了一个队列，该队列的作用是维护一个等待signal信号的队列，两个队列的作用是不同，事实上，每个线程也仅仅会同时存在以上两个队列中的一个，流程是这样的
    
    线程1调用reentrantLock.lock时，线程被加入到AQS的等待队列中。
    
    线程1调用await方法被调用时，该线程从AQS中移除，对应操作是锁的释放。
    
    接着马上被加入到Condition的等待队列中，以为着该线程需要signal信号。
    
    线程2，因为线程1释放锁的关系，被唤醒，并判断可以获取锁，于是线程2获取锁，并被加入到AQS的等待队列中。
    
    线程2调用signal方法，这个时候Condition的等待队列中只有线程1一个节点，于是它被取出来，并被加入到AQS的等待队列中。 注意，这个时候，线程1 并没有被唤醒。
    
    signal方法执行完毕，线程2调用reentrantLock.unLock()方法，释放锁。这个时候因为AQS中只有线程1，于是，AQS释放锁后按从头到尾的顺序唤醒线程时，线程1被唤醒，于是线程1回复执行。
    
    直到释放所整个过程执行完毕。
    
    可以看到，整个协作过程是靠结点在AQS的等待队列和Condition的等待队列中来回移动实现的，Condition作为一个条件类，很好的自己维护了一个等待信号的队列，并在适时的时候将结点加入到AQS的等待队列中来实现的唤醒操作。
    
## 28.	Fork/Join框架的理解?
    Oracle的官方给出的定义是：Fork/Join框架是一个实现了ExecutorService接口的多线程处理器。它可以把一个大的任务划分为若干个小的任务并发执行，充分利用可用的资源，进而提高应用的执行效率。
    
    我们再通过Fork和Join这两个单词来理解下Fork/Join框架，Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。
    
    使用Fork/Join框架分为两步：
    分割任务：首先需要创建一个ForkJoin任务，执行该类的fork方法可以对任务不断切割，直到分割的子任务足够小
    
    合并任务执行结果：子任务执行的结果同一放在一个队列中，通过启动一个线程从队列中取执行结果。
    
    Fork/Join实现了ExecutorService，所以它的任务也需要放在线程池中执行。它的不同在于它使用了工作窃取算法，空闲的线程可以从满负荷的线程中窃取任务来帮忙执行。
    
    代码中使用了FokJoinTask，其与一般任务的区别在于它需要实现compute方法，在方法需要判断任务是否在阈值区间内，如果不是则需要把任务切分到足够小，直到能够进行计算。

    每个被切分的子任务又会重新进入compute方法，再继续判断是否需要继续切分，如果不需要则直接得到子任务执行的结果，如果需要的话则继续切分，如此循环，直到调用join方法得到最终的结果。 * 可以发现Fork/Join框架的需要把提交给ForkJoinPool，ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，前者负责将存放程序提交给ForkJoinPool的任务，后者则负责执行这些任务。
    
## 29.	wait()和sleep()的区别?
    sleep()
    
    方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。
    
    因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。
    
    wait()
    
    wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程
    
## 30.	线程的五个状态（五种状态，创建、就绪、运行、阻塞和死亡）?
    线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。
    
    第一是创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。
    
    第二是就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
    
    第三是运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。
    
    第四是阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。
    
    第五是死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 
    
## 31.	start()方法和run()方法的区别？
    每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。
    
    start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。
    
    run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。
    
## 32.	Runnable接口和Callable接口的区别？
    有点深的问题了，也看出一个Java程序员学习知识的广度。
    
    Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
    
    Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。
    
    这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。
    
## 33.	volatile关键字的作用？
    volatile关键字的作用主要有两个：
    
    （1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据
    
    （2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–>字节码–>根据字节码执行对应的C/C++代码–>C/C++代码被编译成汇编语言–>和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率
    
    从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。
    
## 34.	Java中如何获取到线程dump文件？
    死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：
    
    （1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java
    
    （2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid
    
    另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈
    
## 35.	线程和进程有什么区别？
    进程是系统进行资源分配的基本单位，有独立的内存地址空间
    
    线程是CPU独立运行和独立调度的基本单位，没有单独地址空间，有独立的栈，局部变量，寄存器， 程序计数器等。
    
    创建进程的开销大，包括创建虚拟地址空间等需要大量系统资源
    
    创建线程开销小，基本上只有一个内核对象和一个堆栈。
    
    一个进程无法直接访问另一个进程的资源；同一进程内的多个线程共享进程的资源。
    
    进程切换开销大，线程切换开销小；进程间通信开销大，线程间通信开销小。
    
    线程属于进程，不能独立执行。每个进程至少要有一个线程，成为主线程
    
## 36.	线程实现的方式有几种（四种）？
    继承Thread类，重写run方法
    
    实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target
    
    实现Callable接口通过FutureTask包装器来创建Thread线程
    
    通过线程池创建线程
    
    前面两种可以归结为一类：无返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果
    
    后面两种可以归结成一类：有返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中
    
## 37.	高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？
    这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：
    
    （1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换
    
    （2）并发不高、任务执行时间长的业务要区分开看：
    
    a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务
    
    b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换
    
    （3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。
    
## 38.	如果你提交任务时，线程池队列已满，这时会发生什么？
    如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。
    
## 39.	锁的等级：方法锁、对象锁、类锁?
    方法锁（synchronized修饰方法时）
    
    通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。
    
    synchronized 方法控制对类成员变量的访问： 每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。
    
    对象锁（synchronized修饰方法或代码块）
    
    当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（方法锁也是对象锁） 　　 　　　
    
    java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的1个好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。　
    
    类锁(synchronized 修饰静态的方法或代码块)
    
    由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只有一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。 　
    
    对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步

## 40.	如果同步块内的线程抛出异常会发生什么？
    这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。
    
## 41.	并发编程（concurrency）并行编程（parallellism）有什么区别？
    并发（concurrency）和并行（parallellism）是：
    
    解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
    
    解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
    
    解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群
    
    所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。
    
## 42.	如何保证多线程下 i++ 结果正确？
    用synchronized和AtomicInteger能保证是你想要的数据，volatile并不能保证。
    可见，就算用了volatile，也不能保证数据是你想要的数据，volatile只能保证你数据的可见性（获取到的是最新的数据，不能保证原子性，说白了，volatile跟原子性没关系）
    
    要保证原子性，对数据的累加，可以用AtomicInteger类；
    
    也可以用synchronized来保证数据的一致性
    
## 43.	一个线程如果出现了运行时异常会怎么样?
    如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放
    
## 44.	如何在两个线程之间共享数据?
    通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的
    
## 45.	生产者消费者模型的作用是什么?
    这个问题很理论，但是很重要：
    
    （1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用
    
    （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约
    
## 46.	怎么唤醒一个阻塞的线程?
    如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
    
## 47.	Java中用到的线程调度算法是什么
    抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。
    
## 48.	单例模式的线程安全性?
    老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：
    
    （1）饿汉式单例模式的写法：线程安全
    
    （2）懒汉式单例模式的写法：非线程安全
    
    （3）双检锁单例模式的写法：线程安全
    
## 49.	线程类的构造方法、静态块是被哪个线程调用的?
    这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。
    
    如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：
    
    （1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的
    
    （2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的
    
## 50.	同步方法和同步块，哪个是更好的选择?
    同步块是更好的选择，因为它不会锁住整个对象（当然也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁
    
## 51.	如何检测死锁？怎么预防死锁？
    所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁
    
    通俗地讲就是两个或多个进程被无限期地阻塞、相互等待的一种状态
    
    死锁产生的原因？
    
    1.因竞争资源发生死锁 现象：系统中供多个进程共享的资源的数目不足以满足全部进程的需要时，就会引起对诸资源的竞争而发生死锁现象 2.进程推进顺序不当发生死锁
    
    死锁的四个必要条件：
    
    互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
    
    请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
    
    不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
    
    环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系
    
    这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。
    
    检测死锁
    
    有两个容器，一个用于保存线程正在请求的锁，一个用于保存线程已经持有的锁。每次加锁之前都会做如下检测:
    
    检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来
    
    遍历第一步中返回的线程，检查自己持有的锁是否正被其中任何一个线程请求，如果第二步返回真,表示出现了死锁
    
    死锁的解除与预防：
    
    理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。
    
    所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。
    
    此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。
    
## 52. Static?class?与non?static?class的区别
    static class（内部静态类）
    
    1、用static修饰的是内部类，此时这个内部类变为静态内部类；对测试有用。 
    2、内部静态类不需要有指向外部类的引用。 3、静态类只能访问外部类的静态成员，不能访问外部类的非静态成员。
    
    non static class（非静态内部类）
    
    1、非静态内部类需要持有对外部类的引用。 
    2、非静态内部类能够访问外部类的静态和非静态成员。 
    3、一个非静态内部类不能脱离外部类实体被创建。 
    4、一个非静态内部类可以访问外部类的数据和方法。
    
## 53. 八种基本数据类型的大小，以及他们的封装类
    八种基本数据类型：int、short、float、double、long、boolean、byte、char。
    封装类分别是：Integer、Short、Float、Double、Long、Boolean、Byte、Character。
    
    boolean 这个试编译环境而定
    byte 1个字节
    short 2个字节
    char 2个字节
    int 4个字节
    long 8个字节
    float 4个字节
    double 8个字节
    
    boolean 1bit，用1个字节的最低位存储，其他7位用0填补
    在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位”。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。
    
## 54. Java?IO与NIO
    NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I/O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征。    
    
    NIO和传统的IO有什么区别呢？
    
    IO是面向流的，NIO是面向块（缓冲区）的。
    
    IO面向流的操作一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。，导致了数据的读取和写入效率不佳。
    
    NIO面向块的操作在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多，同时数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。通俗来说，NIO采取了“预读”的方式，当你读取某一部分数据时，他就会猜测你下一步可能会读取的数据而预先缓冲下来。
    
    IO是阻塞的，NIO是非阻塞的
    
    对于传统的IO，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。
    
    而对于NIO，使用一个线程发送读取数据请求，没有得到响应之前，线程是空闲的，此时线程可以去执行别的任务，而不是像IO中那样只能等待响应完成。
    
    NIO和IO适用场景
    
    NIO是为弥补传统IO的不足而诞生的，但是尺有所短寸有所长，NIO也有缺点，因为NIO是面向缓冲区的操作，每一次的数据处理都是对缓冲区进行的，那么就会有一个问题，在数据处理之前必须要判断缓冲区的数据是否完整或者已经读取完毕，如果没有，假设数据只读取了一部分，那么对不完整的数据处理没有任何意义。所以每次数据处理之前都要检测缓冲区数据。
    
    那么NIO和IO各适用的场景是什么呢？
    
    如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候用NIO处理数据可能是个很好的选择。
    
    而如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更合适。使用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作比较来权衡选择。
    
    通俗解释，最后，对于NIO和传统IO
    
    有一个网友讲的生动的例子：
    
    以前的流总是堵塞的，一个线程只要对它进行操作，其它操作就会被堵塞，也就相当于水管没有阀门，你伸手接水的时候，不管水到了没有，你就都只能耗在接水（流）上。
    
    nio的Channel的加入，相当于增加了水龙头（有阀门），虽然一个时刻也只能接一个水管的水，但依赖轮换策略，在水量不大的时候，各个水管里流出来的水，都可以得到妥
    
    善接纳，这个关键之处就是增加了一个接水工，也就是Selector，他负责协调，也就是看哪根水管有水了的话，在当前水管的水接到一定程度的时候，就切换一下：临时关上当
    
    前水龙头，试着打开另一个水龙头（看看有没有水）。
    
    当其他人需要用水的时候，不是直接去接水，而是事前提了一个水桶给接水工，这个水桶就是Buffer。也就是，其他人虽然也可能要等，但不会在现场等，而是回家等，可以做
    
    其它事去，水接满了，接水工会通知他们。
    
    这其实也是非常接近当前社会分工细化的现实，也是统分利用现有资源达到并发效果的一种很经济的手段，而不是动不动就来个并行处理，虽然那样是最简单的，但也是最浪费资源的方式。
    
## 55. java反射的作用于原理   
    什么是Java的反射呢？
    
    Java 反射是可以让我们在运行时，通过一个类的Class对象来获取它获取类的方法、属性、父类、接口等类的内部信息的机制。
    
    这种动态获取信息以及动态调用对象的方法的功能称为JAVA的反射。
    
    反射的作用？
    
    反射就是：在任意一个方法里：
    
    1.如果我知道一个类的名称/或者它的一个实例对象， 我就能把这个类的所有方法和变量的信息找出来(方法名，变量名，方法，修饰符，类型，方法参数等等所有信息)
    
    2.如果我还明确知道这个类里某个变量的名称，我还能得到这个变量当前的值。
    
    3.当然，如果我明确知道这个类里的某个方法名+参数个数类型，我还能通过传递参数来运行那个类里的那个方法。
    
    反射机制主要提供了以下功能：
    
    在运行时判断任意一个对象所属的类。
    
    在运行时构造任意一个类的对象。
    
    在运行时判断任意一个类所具有的成员变量和方法。
    
    在运行时调用任意一个对象的方法。
    
    生成动态代理。
    
    反射的原理？
    
    JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。
    
    反射的实现API有哪些？
    
    反射的实现主要借助以下四个类：
    
    Class：类的对象
    
    Constructor：类的构造方法
    
    Field：类中的属性对象
    
    Method：类中的方法对象 
    
## 56. 泛型常用特点
    不可以强转类型的
    
    这个问题涉及到了，范型向上转型 和 范型向下转型问题。 List向上转换至List（等价于List）会丢失String类的身份（String类型的特有接口）。 当需要由List向下转型时，你的程序必须明确的知道将对象转换成何种具体类型，不然这将是不安全的操作
    
    泛型的类型参数只能是类类型，不能是简单类型。
    不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错
    
    同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。
    类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。
    
    可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。
    
    静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。
    
    即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。