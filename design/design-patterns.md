## 1、单一职责原则
   
   不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。
   
## 2、里氏替换原则（Liskov Substitution Principle）
   
   任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
   
   里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。
   
## 3、依赖倒转原则（Dependence Inversion Principle）
   
   面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。
   
## 4、接口隔离原则（Interface Segregation Principle）
   
   每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。
   
## 5、迪米特法则（最少知道原则）（Demeter Principle）
   
   一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。
   
   最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。
   
## 6、合成复用原则（Composite Reuse Principle）
   
   尽量首先使用合成/聚合的方式，而不是使用继承。

---
## 创建型模式

### 单例模式（Singleton）
  简介：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
  定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式
  特点：1、单例类只有一个实例对象；  
       2、该单例对象必须由单例类自行创建；  
       3、单例类对外提供一个访问该单例的全局访问点；  
  适用场景：  
       在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。  
       当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。  
       当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
       
### 原型模式（Prototype）
  简介：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。  
  定义：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。  
  适用场景：  
       对象之间相同或相似，即只是个别的几个属性不同的时候。  
       对象的创建过程比较麻烦，但复制比较简单的时候。
  注意点：clone()浅拷贝，deep clone深拷贝需要序列化处理
  
### 工厂方法模式（FactoryMethod）
  简介：定义一个用于创建产品的接口，由子类决定生产什么产品。  
  定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。  
  优点：用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；  
       在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；  
  缺点：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。  
  适用场景：  
       客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。  
       创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。  
       客户不关心创建产品的细节，只关心产品的品牌。  
  注意点：如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。  

### 抽象工厂模式（AbstractFactory）  
  简介：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。  
  定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。  
  使用条件：  
  系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。  
  系统一次只可能消费其中某一族产品，即同族的产品一起使用。  
  优点：可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。  
       当增加一个新的产品族时不需要修改原代码，满足开闭原则。
  缺点：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。  
  适用场景：  
       当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。  
       系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。  
       系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。  
  注意点：  
      抽象工厂模式的扩展有一定的“开闭原则”倾斜性：  
      当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。  
      当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。  
      另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。
       
### 建造者模式（Builder）
  简介：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。  
  定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。  
  优点：  
      各个具体的建造者相互独立，有利于系统的扩展。  
      客户端不必知道产品内部组成的细节，便于控制细节风险。  
  缺点：  
      产品的组成部分必须相同，这限制了其使用范围。  
      如果产品的内部变化复杂，该模式会增加很多的建造者类。  
  适用场景：
      创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。  
      创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。  
  注意点：建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用  
  
---

## 结构型模式

### 代理模式模式（Proxy）
  简介：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。  
  定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。  
  优点：  
      代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；  
      代理对象可以扩展目标对象的功能；  
      代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；    
  缺点：
      在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；  
      增加了系统的复杂度；  
  适用场景：  
      远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。  
      虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。  
      安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。  
      智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。  
      延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。  
  注意点：  
      代理类中包含了对真实主题的引用，这种方式存在两个缺点。  
      真实主题与代理主题一一对应，增加真实主题也要增加代理。  
      设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题  
      
### 适配器模式（Adapter）
  简介：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。  
  定义：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。  
  优点：  
      客户端通过适配器可以透明地调用目标接口。  
      复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。  
      将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。  
  缺点：  
      对类适配器来说，更换适配器的实现过程比较复杂。  
  适用场景：  
      以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。  
      使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同  
      
### 桥接模式（Bridge）
  简介：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。  
  定义：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。  
  优点：  
      由于抽象与实现分离，所以扩展能力强；  
      其实现细节对客户透明。  
  缺点：  
      由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。  
  适用场景：  
      当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。  
      当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。  
      当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。  
      
### 装饰模式（Decorator）
  简介：动态地给对象增加一些职责，即增加其额外的功能。  
  定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。  
  优点：  
      采用装饰模式扩展对象的功能比采用继承方式更加灵活。  
      可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。  
  缺点：  
      装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。  
  适用场景：  
      当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。  
      当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。  
      当对象的功能要求可以动态地添加，也可以再动态地撤销时。  
  注意点：  
      装饰模式在 Java 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。  
      例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，  
      还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。
  
### 外观模式（Facade）
  简介：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。  
  定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。  
  优点：  
      降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。  
      对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。  
      降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。  
  缺点：  
      不能很好地限制客户使用子系统类。  
      增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。  
  适用场景：  
      对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。  
      当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。  
      当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。  
      
### 享元模式（Flyweight）
  简介：运用共享技术来有效地支持大量细粒度对象的复用。  
  定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。  
  优点：  
      相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。  
  缺点：  
      为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。  
      读取享元模式的外部状态会使得运行时间稍微变长。  
  适用场景：  
      系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。  
      大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。  
      由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。  
  注意点：  
      单例模式是类级别的，一个类只能有一个对象实例；  
      享元模式是对象级别的，可以有多个对象实例，多个变量引用同一个对象实例；  
      享元模式主要是为了节约内存空间，提高系统性能，而单例模式主要为了可以共享数据；  

### 组合模式（Composite）
  简介：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。  
  定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。  
  优点：  
      组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；  
      更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；  
  缺点：  
      计较复杂，客户端需要花更多时间理清类之间的层次关系；  
      不容易限制容器中的构件；  
      不容易用继承的方法来增加构件的新功能；  
  适用场景：  
      在需要表示一个对象整体与部分的层次结构的场合。  
      要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。  
      
---   
  
## 行为型模式

### 模版方法模式（Template Method）
  简介：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。  
  定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。  
  优点：  
      它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。  
      它在父类中提取了公共的部分代码，便于代码复用。  
      部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。  
  缺点：  
      对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。  
      父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。  
  适用场景：  
      算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。  
      当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。  
      当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。  
      
### 策略模式（Strategy）
  简介：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。  
  定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。  
  优点：  
      多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。  
      策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。  
      策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。  
      策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。  
      策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。  
  缺点：  
      客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。  
      策略模式造成很多的策略类。  
  适用场景：  
      一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。  
      一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。  
      系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。  
      系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。  
      多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。        
      
### 命令模式（Command）
  简介：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。  
  定义：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。  
  优点：  
      降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。  
      增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。  
      可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。  
      方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。  
  缺点：  
      可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。  
  适用场景：  
      当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。
      当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。
      当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。
      当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。
      
### 责任链模式（Chain of Responsibility）
  简介：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。  
  定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。  
  优点：  
      降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。  
      增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。  
      增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。  
      责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。  
      责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。  
  缺点：  
      不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。  
      对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。  
      职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。  
  适用场景：  
      有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。  
      可动态指定一组对象处理请求，或添加新的处理者。  
      在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。  
  注意点：  
      纯的职责链模式：  
      一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：  自己处理（承担责任）；把责任推给下家处理。  
      不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。  
      一般的应用都是不纯的链。
      

### 状态模式（State）
  简介：允许一个对象在其内部状态发生改变时改变其行为能力。  
  定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。  
  优点：  
      状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。  
      减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。  
      有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。  
  缺点：  
      状态模式的使用必然会增加系统的类与对象的个数。  
      状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。  
  适用场景：  
      当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。  
      一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。  
      
### 观察者模式（Observer）
  简介：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。  
  定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。  
  优点：  
      降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。  
      目标与观察者之间建立了一套触发机制。  
  缺点：  
      目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。  
      当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。  
  适用场景：  
      对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。  
      当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。  
  注意点：  
      在翻阅资料的时候，有人把观察者（Observer）模式等同于发布（Publish）/订阅（Subscribe）模式，也有人认为这两种模式还是存在差异，而我认为确实是存在差异的，本质上的区别是调度的地方不同。  
      1. 从两张图片可以看到，最大的区别是调度的地方。  
      虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者、具体目标可认为是发布者），但是观察者模式是由具体目标调度的，而发布/订阅模式是统一由调度中心调的，所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会。  
      2. 两种模式都可以用于松散耦合，改进代码管理和潜在的复用。  
      
### 中介者模式（Mediator）
  简介：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。  
  定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。  
  优点：  
      降低了对象之间的耦合性，使得对象易于独立地被复用。  
      将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。  
  缺点：  
      当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。  
  适用场景：  
      当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。  
      当想创建一个运行于多个类之间的对象，又不想生成新的子类时。  
      
### 迭代器模式（Iterator）
  简介：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。  
  定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。  
  优点：  
      访问一个聚合对象的内容而无须暴露它的内部表示。  
      遍历任务交由迭代器完成，这简化了聚合类。  
      它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。  
      增加新的聚合类和迭代器类都很方便，无须修改原有代码。  
      封装性良好，为遍历不同的聚合结构提供一个统一的接口。  
  缺点：  
      增加了类的个数，这在一定程度上增加了系统的复杂性。  
  适用场景：  
      当需要为聚合对象提供多种遍历方式时。  
      当需要为遍历不同的聚合结构提供一个统一的接口时。  
      当访问一个聚合对象的内容而无须暴露其内部细节的表示时。  
  注意点：  
      由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。  
      
### 访问者模式（Visitor）
  简介：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。  
  定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。  
  优点：  
      扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。  
      复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。  
      灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。  
      符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。  
  缺点：  
      增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。  
      破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。  
      违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。  
  适用场景：  
      对象结构相对稳定，但其操作算法经常变化的程序。  
      对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。  
      对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。  
      
### 备忘录模式（Memento）
  简介：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。  
  定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。  
  优点：  
      提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。  
      实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。  
      简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。  
  缺点：  
      资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。  
  适用场景：  
      需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。  
      需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。  
  
### 解释器模式（Interpreter）
  简介：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。  
  定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。  
  优点：  
      扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。  
      容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。  
  缺点：  
      执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。  
      会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。  
      可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。  
  适用场景：  
      当语言的文法较为简单，且执行效率不是关键问题时。  
      当问题重复出现，且可以用一种简单的语言来进行表达时。  
      当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。  
  注意点：  
      解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计。


